import type { Glyph, GlyphRepr, Glyphs, Meaning } from './types';

export const categories = {
	m: { name: 'Monadic function', bgColor: '#fdffb6', fgColor: '#ccac2b' },
	d: { name: 'Dyadic function', bgColor: '#ffd6a5', fgColor: '#ff4500' },
	a: { name: 'Monadic operator', bgColor: '#9bf6ff', fgColor: '#0dd3bb' },
	c: { name: 'Dyadic operator', bgColor: '#a0c4ff', fgColor: '#7193ff' },
	r: { name: 'Array', bgColor: '#ffadad', fgColor: '#ea0027' },
	h: { name: 'Hyperator', bgColor: '#caffbf', fgColor: '#94e044' },
	s: { name: 'Syntax', bgColor: '#ffc6ff', fgColor: '#ff66ac' },
}

const dy = 'dy', ex = 'ex', vi = 'vi', dz = 'dz', n2 = 'n2', a2 = 'a2', gn = 'gn', i1 = 'i1', i2 = 'i2', ax = 'ax', ng = 'ng', ka = 'ka', aw = 'aw', th = 'th', sv = 'sv', al = 'al', co = 'co', sa = 'sa', a6 = 'a6', ap = 'ap', na = 'na', bq = 'bq', ty = 'ty';

const
	R = 'R',
	My = 'My', xDy = 'xDy',
	uAy = '(uA)y', xuAy = 'x(uA)y', mAy = '(mA)y', xmAy = 'x(mA)y', dAy = '(dA)y', xdAy = 'x(dA)y',
	uCvy = '(uCv)y', xuCvy = 'x(uCv)y', uCny = '(uCn)y', xuCny = 'x(uCn)y', uCey = '(uCe)y', xuCey = 'x(uCe)y',
	mCvy = '(mCv)y', xmCvy = 'x(mCv)y', mCny = '(mCn)y', xmCny = 'x(mCn)y', mCey = '(mCe)y', xmCey = 'x(mCe)y',
	dCvy = '(dCv)y', xdCvy = 'x(dCv)y', dCny = '(dCn)y', xdCny = 'x(dCn)y', dCey = '(dCe)y', xdCey = 'x(dCe)y';

const me = (patterns: string[], names: string[], description: string | undefined = undefined, urls: Record<string, string> = {}) => ({ names, patterns, description, category: 'm', urls } as Meaning);
const sy = (names: string[], description: string | undefined = undefined, urls: Record<string, string> = {}) => ({ names, description, category: 's', urls } as Meaning);

const gl = (glyph: GlyphRepr, ...meanings: [string, ...string[]][]) => ({ glyph, meanings: meanings.map(_ => [_[0], _.slice(1)]) } as Glyph);

export const glyphs: Glyphs = {
	dialects: {
		dy: { name: 'Dyalog APL', shortName: 'Dy' },
		ex: { name: 'Extended Dyalog APL', shortName: 'ExD' },
		vi: { name: 'Dyalog APL Vision', shortName: 'DVi' },
		dz: { name: 'dzaima/APL', shortName: 'dz' },
		n2: { name: 'NARS2000', shortName: 'N2k' },
		a2: { name: 'APL2', shortName: 'A2' },
		gn: { name: 'GNU APL', shortName: 'GNU' },
		i1: { name: 'ISO 8485:1989', shortName: '\'89' },
		i2: { name: 'ISO/IEC 13751:2001', shortName: '\'01' },
		ax: { name: 'APLX', shortName: 'AX' },
		ng: { name: 'ngn/apl', shortName: 'ngn' },
		ka: { name: 'Kap', shortName: 'Kap' },
		aw: { name: 'APL+WIN', shortName: 'A+W' },
		th: { name: 'APL\\360', shortName: '360' },
		sv: { name: 'APL.SV', shortName: 'SV' },
		al: { name: 'April', shortName: 'Apr' },
		co: { name: 'Co-dfns', shortName: 'Co' },
		sa: { name: 'SAX', shortName: 'SAX' },
		a6: { name: 'APL64', shortName: 'A64' },
		ap: { name: 'A+', shortName: 'A+' },
		na: { name: 'NARS', shortName: 'NARS' },
		ty: { name: 'TinyAPL', shortName: 'Ty' },
		bq: { name: 'BQN', shortName: 'BQN', hidden: true },
	},
	urls: {
		wiki: { name: 'APL Wiki' },
		dyalog: { name: 'Dyalog Reference' },
		nars2000: { name: 'NARS2000 Wiki' },
		gnu: { name: 'GNU APL Documentation' },
		paper: { name: 'Paper' },
		gh: { name: 'GitHub' },
		wikipedia: { name: 'Wikipedia' },
		aplx: { name: 'APLX Reference' },
		kap: { name: 'Kap Reference' },
		bqn: { name: 'BQN Reference' },
		tiny: { name: 'TinyAPL Documentation' }
	},
	meanings: {
		conj: me([My], ['Conjugate'], '(Hyper)complex conjugate', { wiki: 'https://aplwiki.com/wiki/Conjugate' }),
		add: me([xDy], ['Addition', 'Sum', 'Plus'], undefined, { wiki: 'https://aplwiki.com/wiki/Add' }),
		plusId: me([My], ['Identity', 'Plus Identity'], undefined, { wiki: 'https://aplwiki.com/wiki/Conjugate' }),
		neg: me([My], ['Negate', 'Negation', 'Invert', 'Inverse', 'Opposite'], undefined, { wiki: 'https://aplwiki.com/wiki/Negate' }),
		sub: me([xDy], ['Subtraction', 'Minus', 'Difference'], undefined, { wiki: 'https://aplwiki.com/wiki/Subtract' }),
		flipLetterCase: me([My], ['Flip Letter Case'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-minus' }),
		sign: me([My], ['Signum', 'Sign', 'Trend'], undefined, { wiki: 'https://aplwiki.com/wiki/Signum' }),
		dir: me([My], ['Direction', 'Signum', 'Sign', 'Trend'], 'Complex signum', { wiki: 'https://aplwiki.com/wiki/Signum' }),
		mul: me([xDy], ['Multiplication', 'Product', 'Times'], undefined, { wiki: 'https://aplwiki.com/wiki/Times' }),
		queryLetterCase: me([My], ['Query Letter Case'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-times' }),
		setLetterCase: me([xDy], ['Set Letter Case'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-times' }),
		rec: me([My], ['Reciprocal', 'Invert', 'Inverse'], undefined, { wiki: 'https://aplwiki.com/wiki/Reciprocal' }),
		div: me([xDy], ['Division', 'Over', 'Divide'], undefined, { wiki: 'https://aplwiki.com/wiki/Divide' }),
		toTitleCase: me([My], ['To Title Case'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-divide' }),
		exp: me([My], ['Exponential', 'exp'], 'Power with Euler\'s number as the base', { wiki: 'https://aplwiki.com/wiki/Exponential' }),
		pow: me([xDy], ['Power'], undefined, { wiki: 'https://aplwiki.com/wiki/Power_(function)' }),
		sqrt: me([My], ['Square Root', 'sqrt'], undefined, { wiki: 'https://aplwiki.com/wiki/Square_Root' }),
		root: me([xDy], ['Root'], undefined, { wiki: 'https://aplwiki.com/wiki/Root' }),
		ln: me([My], ['Natural Logarithm', 'log', 'ln'], undefined, { wiki: 'https://aplwiki.com/wiki/Natural_Logarithm' }),
		log: me([xDy], ['Logarithm', 'log'], undefined, { wiki: 'https://aplwiki.com/wiki/Logarithm' }),
		mInv: me([My], ['Matrix Inverse', 'Invert', 'Inverse'], undefined, { wiki: 'https://aplwiki.com/wiki/Matrix_Inverse' }),
		mDiv: me([xDy], ['Matrix Division', 'Solve', 'Matrix Divide'], undefined, { wiki: 'https://aplwiki.com/wiki/Matrix_Divide' }),
		piT: me([My], ['Pi Times'], undefined, { wiki: 'https://aplwiki.com/wiki/Pi_Times' }),
		circ: me([xDy], ['Circular Functions', 'Trigonometric Functions', 'Hyperbolic Functions', 'Pythagorean Functions'], 'A range of trigonometric and related functions selected using the left argument', { wiki: 'https://aplwiki.com/wiki/Circular' }),
		fact: me([My], ['Factorial', 'Gamma Function'], undefined, { wiki: 'https://aplwiki.com/wiki/Factorial' }),
		binom: me([xDy], ['Binomial Coefficient', 'Choose'], undefined, { wiki: 'https://aplwiki.com/wiki/Binomial' }),
		roll: me([My], ['Roll', 'Random'], 'Random numbers as specified by the argument', { wiki: 'https://aplwiki.com/wiki/Roll' }),
		deal: me([xDy], ['Deal'], 'Right argument random selections from the range defined by the left argument', { wiki: 'https://aplwiki.com/wiki/Deal' }),
		abs: me([My], ['Absolute Value', 'abs'], undefined, { wiki: 'https://aplwiki.com/wiki/Magnitude' }),
		mag: me([My], ['Magnitude'], undefined, { wiki: 'https://aplwiki.com/wiki/Magnitude' }),
		mod: me([xDy], ['Residue', 'Remainder', 'Modulus', 'Modulo'], undefined, { wiki: 'https://aplwiki.com/wiki/Residue' }),
		caseFold: me([My], ['Case Fold'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-stile' }),
		ceil: me([My], ['Ceiling', 'Nearest Integer Above'], 'The smallest integer greater than or equal to the argument', { wiki: 'https://aplwiki.com/wiki/Ceiling' }),
		max: me([xDy], ['Maximum', 'max'], 'The largest argument', { wiki: 'https://aplwiki.com/wiki/Maximum' }),
		maxTAO: me([xDy], ['Maximal', 'TAO Maximum'], 'The largest argument, as whole arrays', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/maximal' }),
		toUpper: me([My], ['To Uppercase'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-upstile' }),
		floor: me([My], ['Floor', 'Nearest Integer Below'], 'The largest integer less than or equal to the argument', { wiki: 'https://aplwiki.com/wiki/Floor' }),
		min: me([xDy], ['Minimum', 'min'], 'The smallest argument', { wiki: 'https://aplwiki.com/wiki/Minimum' }),
		minTAO: me([xDy], ['Minimal', 'TAO Minimum'], 'The smallest argument, as whole arrays', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/minimal' }),
		toLower: me([My], ['To Lowercase'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-downstile' }),
		decode: me([xDy], ['Decode', 'Base', 'Evaluate Polynomial'], 'Evaluate the right argument in the base defined by the left argument', { wiki: 'https://aplwiki.com/wiki/Decode' }),
		decode2: me([My], ['Base-2 Decode', 'Binary Decode', 'Binary Base'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-uptack' }),
		encode: me([xDy], ['Encode', 'Antibase'], 'Represent the right argument in the base defined by the left argument', { wiki: 'https://aplwiki.com/wiki/Encode' }),
		encode2: me([My], ['Base-2 Encode', 'Binary Encode', 'Binary Antibase'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-downtack' }),
		type: me([My], ['Type'], 'Prototype array corresponding to the argument', { wiki: 'https://aplwiki.com/wiki/Type' }),
		same: me([My], ['Same', 'Identity'], 'The argument, unchanged', { wiki: 'https://aplwiki.com/wiki/Identity' }),
		right: me([xDy], ['Right', 'Dex', 'Identity'], 'The right argument, unchanged', { wiki: 'https://aplwiki.com/wiki/Identity' }),
		left: me([xDy], ['Left', 'Lev', 'Identity'], 'The left argument, unchanged', { wiki: 'https://aplwiki.com/wiki/Identity' }),
		eq: me([xDy], ['Equal To', 'Equals', 'eq'], undefined, { wiki: 'https://aplwiki.com/wiki/Equal_to' }),
		isType: me([My], ['Is Type?'], 'Equal to type', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-equals' }),
		dimension: me([My], ['Dimension'], 'Hypercomplex dimension (1, 2, 4, or 8)'),
		neq: me([xDy], ['Not Equal To', 'Not Equals', 'neq'], undefined, { wiki: 'https://aplwiki.com/wiki/Not_Equal_to' }),
		nubSieve: me([My], ['Nub Sieve', 'Nubsieve', 'Unique Mask', 'Nub Mask'], 'Mask that marks the first occurrence of each element', { wiki: 'https://aplwiki.com/wiki/Nub_Sieve' }),
		isNotType: me([My], ['Is Not Type?'], 'Not equal to type', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-notequalto' }),
		norm: me([My], ['Norm'], 'Argument times the conjugate of the argument'),
		leq: me([xDy], ['Less Than or Equal To', 'leq', 'lte'], undefined, { wiki: 'https://aplwiki.com/wiki/Less_than_or_Equal_to' }),
		isNonneg: me([My], ['Is Nonnegative?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-lessthanorequalto' }),
		isInvisible: me([My], ['Is Invisible Character?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-lessthanorequalto' }),
		sortAsc: me([My], ['Sort Ascending'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-wedge' }),
		le: me([xDy], ['Less Than', 'lt'], undefined, { wiki: 'https://aplwiki.com/wiki/Less_than' }),
		isPos: me([My], ['Is Positive?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-lessthan' }),
		isControl: me([My], ['Is Control Character?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-lessthan' }),
		majorCells: me([My], ['Major Cells'], undefined, { wiki: 'https://aplwiki.com/wiki/Major_cell' }),
		condense: me([My], ['Condense'], 'Compress a real array into an array of hypercomplex numbers', { nars2000: 'https://wiki.nars2000.org/index.php?title=Condense' }),
		ge: me([xDy], ['Greater Than', 'gt'], undefined, { wiki: 'https://aplwiki.com/wiki/Greater_than' }),
		isNeg: me([My], ['Is Negative?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-greaterthan' }),
		isVisible: me([My], ['Is Visible Character?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-greaterthan' }),
		join: me([My], ['Join', 'Raze'], 'Merge array of arrays into single array', { wiki: 'https://aplwiki.com/wiki/Raze' }),
		dilate: me([My], ['Dilate'], 'Expand an array of hypercomplex numbers into an array of reals', { nars2000: 'https://wiki.nars2000.org/index.php?title=Dilate' }),
		geq: me([xDy], ['Greater Than or Equal To', 'geq', 'gte'], undefined, { wiki: 'https://aplwiki.com/wiki/Greater_than_or_Equal_to' }),
		isNonpos: me([My], ['Is Nonpositive?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-greaterthanorequalto' }),
		isNotControl: me([My], ['Is Not Control Character?'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-greaterthanorequalto'}),
		sortDesc: me([My], ['Sort Descending'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-vel' }),
		match: me([xDy], ['Match', 'All Equal', 'TAO Equal'], 'Compare the whole arrays for equality', { wiki: 'https://aplwiki.com/wiki/Match' }),
		depth: me([My], ['Depth'], 'Level of nesting', { wiki: 'https://aplwiki.com/wiki/Depth' }),
		mismatch: me([xDy], ['Not Match', 'Natch', 'Not All Equal', 'TAO Not Equal'], undefined, { wiki: 'https://aplwiki.com/wiki/Not_Match' }),
		tally: me([My], ['Tally', 'Count'], 'The amount of major cells', { wiki: 'https://aplwiki.com/wiki/Tally' }),
		pid: me([xDy], ['Precedes or Identical', 'Precedes or Match', 'TAO Less Than Or Equal To'], 'Compare the whole arrays for precedence or equality', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/precedes_or_identical' }),
		prec: me([xDy], ['Precedes', 'TAO Less Than'], 'Compare the whole arrays for precedence', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/precedes' }),
		succ: me([xDy], ['Succeeds', 'TAO Greater Than'], 'Compare the whole arrays for precedence', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/succeeds' }),
		sid: me([xDy], ['Succeeds or Identical', 'Succeeds or Match', 'TAO Greater Than Or Equal To'], 'Compare the whole arrays for precedence or equality', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/succeeds_or_identical' }),
		or: me([xDy], ['Or'], undefined, { wiki: 'https://aplwiki.com/wiki/Or' }),
		gcd: me([xDy], ['Greatest Common Divisor', 'GCD'], undefined, { wiki: 'https://aplwiki.com/wiki/GCD' }),
		demote: me([My], ['Demote'], 'Combine two leading axes (like ,[⍳2])', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_greater_thandecrease_rank' }),
		gcdM: me([My], ['Monadic GCD'], 'GCD reduction (any 1?)', { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L13' }),
		and: me([xDy], ['And'], undefined, { wiki: 'https://aplwiki.com/wiki/And' }),
		lcm: me([xDy], ['Least Common Multiple', 'LCM'], undefined, { wiki: 'https://aplwiki.com/wiki/LCM' }),
		promote: me([My], ['Promote'], 'Add a length-1 axis before the other axes', { wiki: 'https://aplwiki.com/wiki/Promote' }),
		lcmM: me([My], ['Monadic LCM'], 'LCM reduction (all 1?)', { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L14' }),
		nor: me([xDy], ['Nor', 'Not Or'], undefined, { wiki: 'https://aplwiki.com/wiki/Nor' }),
		notAnyEqualToType: me([My], ['Not Any Equal To Type'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-nand' }),
		notAll: me([My], ['Not All'], 'Any 0?', { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L15' }),
		nand: me([xDy], ['Nand', 'Not And'], undefined, { wiki: 'https://aplwiki.com/wiki/Nand' }),
		notAllEqualToType: me([My], ['Not All Equal To Type'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-nor' }),
		none: me([My], ['None'], 'All 0?', { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L16' }),
		mix: me([My], ['Mix', 'Disclose', 'Open'], 'Combine all elements into a single array', { wiki: 'https://aplwiki.com/wiki/Mix' }),
		take: me([xDy], ['Take'], undefined, { wiki: 'https://aplwiki.com/wiki/Take' }),
		split: me([My], ['Split'], 'Convert an axis to a level of nesting', { wiki: 'https://aplwiki.com/wiki/Split' }),
		drop: me([xDy], ['Drop'], undefined, { wiki: 'https://aplwiki.com/wiki/Drop' }),
		enclose: me([My], ['Enclose', 'Box'], 'Wrap the argument into a nested scalar', { wiki: 'https://aplwiki.com/wiki/Enclose' }),
		penclose: me([xDy], ['Partitioned Enclose'], 'Split the right argument into pieces specified by the left argument', { wiki: 'https://aplwiki.com/wiki/Partitioned_Enclose' }),
		partition: me([xDy], ['Partition'], 'Split the right argument into pieces specified by the left argument', { wiki: 'https://aplwiki.com/wiki/Partition' }),
		first: me([My], ['First', 'Disclose'], 'The first element of the argument', { wiki: 'https://aplwiki.com/wiki/First' }),
		firstCell: me([My], ['First Cell'], 'The first cell of the argument', { bqn: 'https://mlochbaum.github.io/BQN/doc/select.html#first-cell' }),
		pick: me([xDy], ['Pick'], 'Extract a value through layers of nesting', { wiki: 'https://aplwiki.com/wiki/Pick' }),
		nest: me([My], ['Nest', 'Conditional Enclose', 'Enclose If Simple'], 'Enclose if simple', { wiki: 'https://aplwiki.com/wiki/Nest' }),
		subset: me([xDy], ['Subset'], 'Is subset?', { nars2000: 'https://wiki.nars2000.org/index.php?title=Sets' }),
		discloseIfScalar: me([My], ['Disclose If Scalar'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-rightshoeunderbar' }),
		from: me([xDy], ['From', 'Select', 'Sane Index'], 'Function form of bracket indexing', { wiki: 'https://aplwiki.com/wiki/From' }),
		last: me([My], ['Last'], 'Last element in ravel order'),
		lastCell: me([My], ['Last Cell'], 'Last cell in the argument'),
		superset: me([xDy], ['Superset'], 'Is superset?', { nars2000: 'https://wiki.nars2000.org/index.php?title=Sets' }),
		index: me([xDy], ['Index', 'Squad Indexing'], 'Items of the right argument as specified by the left argument', { wiki: 'https://aplwiki.com/wiki/Index_(function)' }),
		materialize: me([My], ['Materialize', 'Materialise'], 'Cast the argument to an array', { wiki: 'https://aplwiki.com/wiki/Materialise' }),
		mapKV: me([My], ['Map Key/Value Pairs'], undefined, { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L25' }),
		gradeUp: me([My], ['Grade Up'], 'Indices that sort the argument in ascending order', { wiki: 'https://aplwiki.com/wiki/Grade' }),
		gradeDown: me([My], ['Grade Down'], 'Indices that sort the argument in descending order', { wiki: 'https://aplwiki.com/wiki/Grade' }),
		gradeUpD: me([xDy], ['Dyadic Grade Up'], 'Indices that sort the right argument in ascending order, according to the left argument', { wiki: 'https://aplwiki.com/wiki/Grade' }),
		gradeDownD: me([xDy], ['Dyadic Grade Down'], 'Indices that sort the right argument in descending order, according to the left argument', { wiki: 'https://aplwiki.com/wiki/Grade' }),
		indexGeneratorR: me([My], ['Index Generator (Range)', 'Iota', 'Indices', 'Range'], 'Numbers in range defined by the argument', { wiki: 'https://aplwiki.com/wiki/Index_Generator' }),
		indexGeneratorI: me([My], ['Index Generator (Indices)', 'Iota', 'Indices', 'Range'], 'Indices with shape specified by the argument', { wiki: 'https://aplwiki.com/wiki/Index_Generator' }),
		indexOf: me([xDy], ['Index Of'], undefined, { wiki: 'https://aplwiki.com/wiki/Index_Of' }),
		progressiveIndexOf: me([xDy], ['Progressive Index Of', 'Multiset Index Of'], 'Index of but non-repeating', { bqn: 'https://mlochbaum.github.io/BQN/doc/search.html#progressive-index-of' }),
		where: me([My], ['Where', 'Indices'], 'True indices in the argument mask', { wiki: 'https://aplwiki.com/wiki/Indices' }),
		intervalIndex: me([xDy], ['Interval Index', 'Bins Up'], 'Determine fitting interval, left argument giving beginning points', { wiki: 'https://aplwiki.com/wiki/Interval_Index', bqn: 'https://mlochbaum.github.io/BQN/doc/order.html#bins' }),
		intervalIndexDown: me([xDy], ['Interval Index Down', 'Bins Down'], undefined, { bqn: 'https://mlochbaum.github.io/BQN/doc/order.html#bins' }),
		arrayLookup: me([xDy], ['Array Lookup'], 'Like ⍳, but on major cells', { nars2000: 'https://wiki.nars2000.org/index.php?title=Array_Lookup' }),
		elementOf: me([xDy], ['Element Of', 'In', 'Membership', 'Member Of', 'Member In'], undefined, { wiki: 'https://aplwiki.com/wiki/Membership' }),
		enlist: me([My], ['Enlist', 'Flatten'], 'All simple elements of the argument, traversing nested elements', { wiki: 'https://aplwiki.com/wiki/Enlist' }),
		find: me([xDy], ['Find'], 'Mask of the start corners of the appearances of the left argument in the right argument', { wiki: 'https://aplwiki.com/wiki/Find' }),
		union: me([xDy], ['Union'], 'The left argument catenated with the elements of the right argument that don\'t appear in the left argument', { wiki: 'https://aplwiki.com/wiki/Union' }),
		nub: me([My], ['Unique', 'Nub'], 'Unique elements', { wiki: 'https://aplwiki.com/wiki/Unique' }),
		intersection: me([xDy], ['Intersection'], 'All elements of the left argument that appear in the right argument', { wiki: 'https://aplwiki.com/wiki/Intersection' }),
		nubIn: me([My], ['Nub In', 'Nub Classify', 'Self Classify', 'Nub-In', 'Nub-Classify', 'Self-Classify'], 'Table of which elements are their unique', { wiki: 'https://aplwiki.com/wiki/Nub_in' }),
		not: me([My], ['Not', 'Inverse'], undefined, { wiki: 'https://aplwiki.com/wiki/Not' }),
		m1: me([My], ['1 Minus'], 'Like Not but extended to floats [0; 1]', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-tilde '}),
		without: me([xDy], ['Without', 'Less', 'Set Difference', 'Excluding', 'And Not'], 'All elements of the left argument that don\'t appear in the right argument', { wiki: 'https://aplwiki.com/wiki/Without' }),
		symDiff: me([xDy], ['Symmetric Difference'], 'Elements that appear in exactly one of the arguments', { nars2000: 'https://wiki.nars2000.org/index.php?title=Sets' }),
		reduce: me([dAy], ['Reduce', 'Fold', 'Reduction', 'Insert'], undefined, { wiki: 'https://aplwiki.com/wiki/Reduce' }),
		reduceF: me([dAy], ['Reduce First', 'Fold First', 'Reduction First', 'Insert First'], undefined, { wiki: 'https://aplwiki.com/wiki/Reduce' }),
		reduceLF: me([dAy], ['Reduce Left First', 'Fold Left First', 'Reduce First Left', 'Fold First Left'], 'Reduce left to right'),
		wreduce: me([xdAy], ['Windowed Reduce', 'Windowed Fold', 'Windowed Reduction', 'Windowed Insert'], undefined, { wiki: 'https://aplwiki.com/wiki/Windowed_Reduce' }),
		wreduceF: me([xdAy], ['Windowed Reduce First', 'Windowed Fold First', 'Windowed Reduction First', 'Windowed Insert First'], undefined, { wiki: 'https://aplwiki.com/wiki/Windowed_Reduce' }),
		compress: me([xDy], ['Compress', 'Filter'], 'Select elements of the right argument marked by the left argument mask', { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		replicate: me([xDy], ['Replicate'], undefined, { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		compressO: me([uAy], ['Compress', 'Filter'], 'Select elements of the argument marked by the operand mask', { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		replicateO: me([uAy], ['Replicate'], undefined, { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		compressF: me([xDy], ['Compress First', 'Filter First'], 'Select elements of the right argument marked by the left argument mask', { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		replicateF: me([xDy], ['Replicate First'], undefined, { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		compressOF: me([uAy], ['Compress First', 'Filter First'], 'Select elements of the argument marked by the operand mask', { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		replicateOF: me([uAy], ['Replicate First'], undefined, { wiki: 'https://aplwiki.com/wiki/Replicate' }),
		scan: me([dAy], ['Scan'], undefined, { wiki: 'https://aplwiki.com/wiki/Scan' }),
		scanF: me([dAy], ['Scan First'], undefined, { wiki: 'https://aplwiki.com/wiki/Scan' }),
		expand: me([xDy], ['Expand'], undefined, { wiki: 'https://aplwiki.com/wiki/Expand' }),
		expandF: me([xDy], ['Expand First'], undefined, { wiki: 'https://aplwiki.com/wiki/Expand' }),
		expandO: me([uAy], ['Expand'], undefined, { wiki: 'https://aplwiki.com/wiki/Expand' }),
		expandOF: me([uAy], ['Expand First'], undefined, { wiki: 'https://aplwiki.com/wiki/Expand' }),
		applyRight: me([xmAy], ['Apply To Right Argument (?)'], '⊢∘f', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-backslashbar' }),
		ravel: me([My], ['Ravel', 'Items'], 'All elements of the argument as a vector', { wiki: 'https://aplwiki.com/wiki/Ravel' }),
		cat: me([xDy], ['Catenate', 'Concatenate'], undefined, { wiki: 'https://aplwiki.com/wiki/Catenate' }),
		table: me([My], ['Ravel Items', 'Table'], undefined, { wiki: 'https://aplwiki.com/wiki/Table' }),
		catF: me([xDy], ['Catenate First', 'Concatenate First'], undefined, { wiki: 'https://aplwiki.com/wiki/Catenate' }),
		shape: me([My], ['Shape'], undefined, { wiki: 'https://aplwiki.com/wiki/Shape' }),
		reshape: me([xDy], ['Reshape', 'Set Shape', 'Change Shape'], undefined, { wiki: 'https://aplwiki.com/wiki/Reshape' }),
		rerank: me([xDy], ['Rerank', 'Set Rank', 'Change Rank'], 'Set the rank of an array by repeatedly promoting or demoting', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/rerank' }),
		reverse: me([My], ['Reverse', 'Flip', 'Reverse Rows'], undefined, { wiki: 'https://aplwiki.com/wiki/Reverse' }),
		rotate: me([xDy], ['Rotate', 'Rotate Rows'], undefined, { wiki: 'https://aplwiki.com/wiki/Rotate' }),
		reverseF: me([My], ['Reverse First', 'Flip First', 'Reverse Columns'], undefined, { wiki: 'https://aplwiki.com/wiki/Reverse' }),
		rotateF: me([xDy], ['Rotate First', 'Rotate Columns'], undefined, { wiki: 'https://aplwiki.com/wiki/Rotate' }),
		transpose: me([My], ['Transpose'], undefined, { wiki: 'https://aplwiki.com/wiki/Transpose#Monadic_usage' }),
		transposeD: me([xDy], ['Reorder Axes', 'Dyadic Transpose'], undefined, { wiki: 'https://aplwiki.com/wiki/Transpose#Dyadic_usage' }),
		each1: me([mAy], ['Each', 'Map'], 'Apply a function to each element of an array', { wiki: 'https://aplwiki.com/wiki/Each' }),
		each2: me([xdAy], ['Each', 'Zip'], 'Apply a function to each element of two arrays', { wiki: 'https://aplwiki.com/wiki/Each' }),
		constant: me([uAy, xuAy], ['Constant', 'K', 'Always'], 'A function that always returns the operand', { wiki: 'https://aplwiki.com/wiki/Constant' }),
		commute: me([xdAy], ['Commute', 'Swap', 'Flip', 'Selfie'], 'Call the operand with the arguments swapped', { wiki: 'https://aplwiki.com/wiki/Commute' }),
		duplicate: me([dAy], ['Duplicate', 'Selfie'], 'Call the operand with the argument as both left and right', { wiki: 'https://aplwiki.com/wiki/Commute' }),
		repeat: me([mCvy, xdCvy], ['Repeat', 'Power'], 'Repeat a function a specified number of times', { wiki: 'https://aplwiki.com/wiki/Power_(operator)' }),
		until: me([mCey, xdCey], ['Repeat Until', 'Power'], 'Repeat a function until a predicate is satisfied', { wiki: 'https://aplwiki.com/wiki/Power_(operator)' }),
		cumulativeRepeat: me([mCvy, xdCvy, mCey, xdCey], ['Cumulative Repeat', 'Cumulative Power'], 'Like ⍣, but collect intermediary results'),
		convolution: me([xdCey], ['Convolution'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=Convolution' }),
		innerProduct: me([xdCey], ['Inner Product', 'Matrix Product'], 'Apply a function to each pair in the arguments and combine the results with another function', { wiki: 'https://aplwiki.com/wiki/Inner_Product' }),
		alternant: me([dCey], ['Alternant', 'Determinant', 'Permanent'], 'Generalized determinant', { wiki: 'https://aplwiki.com/wiki/Determinant', nars2000: 'https://wiki.nars2000.org/index.php?title=Determinant_Operator' }),
		outerProduct: me([xdAy], ['Outer Product', 'Table'], 'Apply a function to the cartesian product of the two arguments', { wiki: 'https://aplwiki.com/wiki/Outer_Product' }),
		compose: me([mCny], ['Compose', 'Composition'], 'Apply a function after another', { wiki: 'https://aplwiki.com/wiki/Compose' }),
		after: me([xdCey], ['After', 'Beside', 'Compose', 'Composition'], 'Preprocess the right argument to a function with another function', { wiki: 'https://aplwiki.com/wiki/Beside' }),
		bind: me([dCvy, uCey], ['Bind'], 'Bind an argument to a dyadic function, making it monadic', { wiki: 'https://aplwiki.com/wiki/Bind' }),
		before: me([mCey, xmCey], ['Before', 'Reverse Compose'], 'Preprocess the left argument to a function with another function', { wiki: 'https://aplwiki.com/wiki/Reverse_Compose' }),
		atop: me([xmCey], ['Atop'], 'Call a monad using the result of a dyad as the argument', { wiki: 'https://aplwiki.com/wiki/Atop_(operator)' }),
		atRank: me([mCvy, xdCvy], ['Rank'], 'Apply a function at a specified rank', { wiki: 'https://aplwiki.com/wiki/Rank_(operator)' }),
		over: me([xdCny], ['Over'], 'Preprocess all arguments to a function with another function', { wiki: 'https://aplwiki.com/wiki/Over' }),
		atDepth: me([mCvy, xdCvy], ['Depth'], 'Apply a function at a specified depth', { wiki: 'https://aplwiki.com/wiki/Depth_(operator)' }),
		under: me([mCny, xdCny], ['Under', 'Dual'], 'Apply a function, then another function, then the first function\'s inverse', { wiki: 'https://aplwiki.com/wiki/Under' }),
		eachLeft: me([xdAy], ['Each Left'], 'Each, only on the left argument', { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L74' }),
		eachRight: me([xdAy], ['Each Right'], 'Each, only on the right argument', { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L75' }),
		cellsLeft: me([xdAy], ['Cells Left'], 'Cells, only on the left argument', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/cells_left' }),
		cellsRight: me([xdAy], ['Cells Right'], 'Cells, only on the right argument', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/cells_right' }),
		at: me([mCny, mCvy, uCny, uCvy], ['At'], 'Transform selected elements of an array', { wiki: 'https://aplwiki.com/wiki/At' }),
		obverse: me([mCny, xdCey], ['Obverse', 'Set Inverse'], 'Specify the inverse function for a function', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-deltilde' }),
		evalInput: sy(['Evaluated Input', 'stdin', 'Quad Input'], 'Input and evaluate as an APL expression', { wiki: 'https://aplwiki.com/wiki/Quad_name' }),
		stdout: sy(['Standard Output', 'stdout', 'Quad Output', 'Print'], undefined, { wiki: 'https://aplwiki.com/wiki/Quad_name' }),
		sys: sy(['System Name', 'Quad Name'], 'First character of a system name', { wiki: 'https://aplwiki.com/wiki/Quad_name' }),
		stringInput: sy(['String Input', 'stdin', 'Quad Quote Input', 'Quote Quad Input'], undefined, { wiki: 'https://aplwiki.com/wiki/Quad_name' }),
		stderr: sy(['Standard Error', 'stderr', 'Quad Quote Output', 'Quote Quad Output'], undefined, { wiki: 'https://aplwiki.com/wiki/Quad_name' }),
		variant: me([mCvy, xdCvy], ['Variant', 'Custom'], 'Select a related function', { wiki: 'https://aplwiki.com/wiki/Variant', dyalog: 'https://help.dyalog.com/18.2/Content/Language/Primitive%20Operators/Variant.htm', nars2000: 'https://wiki.nars2000.org/index.php?title=Variant' }),
		keyI: me([dAy], ['Key (Indices)'], 'Apply a function to unique elements of an array and their indices', { wiki: 'https://aplwiki.com/wiki/Key' }),
		keyV: me([xdAy], ['Key (Values)'], 'Apply a function to unique elements of the left array and the corresponding entries in the right array', { wiki: 'https://aplwiki.com/wiki/Key' }),
		keyVocI: me([uAy], ['Key With Vocabulary (Indices)'], 'Locations of each element in the vocabulary in the argument', { gh: 'https://github.com/abrudz/dyalog_vision#user-content-quadequal' }),
		keyVocV: me([xuAy], ['Key With Vocabulary (Values)'], 'Elements of the left argument corresponding to locations of elements in the vocabulary in the right argument', { gh: 'https://github.com/abrudz/dyalog_vision#user-content-quadequal' }),
		getMap: me([uAy], ['Get In Map'], undefined, { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L73' }),
		setMap: me([xuAy], ['Set In Map'], undefined, { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L73' }),
		diagonals: me([mAy], ['Diagonals'], 'Apply a function to each diagonal of a matrix', { gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L89' }),
		stencil: me([dCvy], ['Stencil'], 'Apply a function to windows of an array', { wiki: 'https://aplwiki.com/wiki/Stencil' }),
		beam: me([uAy, xuAy], ['I-Beam', 'I Beam'], 'Access non-primitive, implementation specific functions', { wiki: 'https://aplwiki.com/wiki/I-Beam', dyalog: 'https://help.dyalog.com/18.2/Content/Language/Primitive%20Operators/I%20Beam.htm' }),
		execute: me([My], ['Execute', 'Evaluate', 'Run'], undefined, { wiki: 'https://aplwiki.com/wiki/Execute' }),
		format: me([My], ['Format', 'Stringify'], undefined, { wiki: 'https://aplwiki.com/wiki/Format#Monadic_form' }),
		dformat: me([xDy], ['Format With Specification'], 'Format specifying column widths, decimal places and optionally scientific notation', { wiki: 'https://aplwiki.com/wiki/Format#Dyadic_form' }),
		zilde: me([R], ['Zilde', 'Empty List', 'Empty Vector'], 'Empty numeric vector', { wiki: 'https://aplwiki.com/wiki/Zilde' }),
		emptyDict: me([R], ['Empty Dictionary', 'Empty Map'], 'Empty dictionary'),
		inf: me([R], ['Infinity'], 'The largest number', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-infinity' }),
		ninf: me([R], ['Negative Infinity'], 'The smallest number', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-negativeinfinity' }),
		nan: me([R], ['Not a Number', 'NaN'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=NaN' }),
		cartM: me([My], ['Imaginary', 'Pure Imaginary'], 'i × arg', { wiki: 'https://aplwiki.com/wiki/Imaginary' }),
		cartD: me([xDy], ['Cartesian', 'Complex'], 'left + i × right', { wiki: 'https://aplwiki.com/wiki/Complex_(function)' }),
		polarM: me([My], ['Polar', 'Unit Polar'], 'e * i × arg', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/unit_polar' }),
		polarD: me([xDy], ['Polar'], 'left × e * i × right', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/polar' }),
		mstringE: me([My], ['String Enhancement (Monadic)', 'Interpolate'], '${expr} inside a string is evaluated', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-dollarsign' }),
		dstringE: me([xDy], ['String Enhancement (Dyadic)', 'Interpolate'], '${idx} is replaced with the corresponding item in the argument', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-dollarsign' }),
		range: me([xDy], ['Range'], undefined, { wiki: 'https://aplwiki.com/wiki/Range' }),
		multisets: me([mAy, xdAy], ['Multisets'], 'Turns set functions into multiset functions', { nars2000: 'https://wiki.nars2000.org/index.php?title=Multisets' }),
		countIn: me([xDy], ['Count In'], 'Count occurrences of each of the left argument in the right argument', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-leftshoestile' }),
		probab: me([xdAy], ['Probability-logical Function'], 'Multiplicative fuzzy logic (probabalistic) function corresponding to the Boolean function given', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-percent' }),
		merge: me([xDy], ['Merge', 'Case'], 'Compose array by choosing each element from the corresponding element in each of a set of sources', { wiki: 'https://aplwiki.com/wiki/Case' }),
		pair: me([xDy], ['Pair'], undefined, { wiki: 'https://aplwiki.com/wiki/Pair' }),
		singleton: me([My], ['Singleton', 'Half Pair'], undefined, { wiki: 'https://aplwiki.com/wiki/Pair', gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-semicolonunderbar' }),
		factors: me([My], ['Factors'], undefined, { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-stiletilde' }),
		primeRelated: me([xDy], ['Prime Related Functions'], 'Prime-related functions on the right argument, selected by left argument', { gh: 'https://github.com/abrudz/dyalog-apl-extended/tree/master#user-content-stiletilde', nars2000: 'https://wiki.nars2000.org/index.php?title=Primes' }),
		primeFactors: me([My], ['Prime Factors'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=Primes' }),
		null: me([mAy, xdAy], ['Ident', 'Null', 'Identity'], 'The identity operator, useful for casting hybrids to functions', { nars2000: 'https://wiki.nars2000.org/index.php?title=Null', tiny: 'https://tinyapl.rubenverg.com/docs/primitive/ident' }),
		lev: me([mCny, mCey, xdCny, xdCey], ['Lev', 'Left'], 'Returns the left operand', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/lev' }),
		dex: me([mCny, mCey, xdCny, xdCey], ['Dex', 'Right'], 'Returns the right operand', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/dex' }),
		combinatorial: me([xuAy], ['Combinatorial'], 'Combinatorial functions selected by the operand', { nars2000: 'https://wiki.nars2000.org/index.php?title=Combinatorial' }),
		matrix: me([mAy, xdAy], ['Matrix'], 'Apply a function to a diagonalizable matrix', { nars2000: 'https://wiki.nars2000.org/index.php?title=Matrix' }),
		deriv: me([mAy, xdAy], ['Derivative'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=Derivative' }),
		integ: me([xmAy], ['Integral'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=Integral' }),
		transform: me(['(d(mH)e)y'], ['Transform'], undefined, { paper: 'http://www.sudleyplace.com/APL/A%20Transform%20Hyperator%20in%20APL.pdf' }),
		dfn: sy(['Dfn'], 'Wrap a dfn (anonymous function) definition', { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function' }),
		dop: sy(['Dop'], 'Wrap a dop (anonymous operator) definition', { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function' }),
		dhyp: sy(['Dhyp'], 'Wrap a dhyp (anonymous hyperator) definition', { nars2000: 'https://wiki.nars2000.org/index.php?title=Anonymous_Functions/Operators/Hyperators' }),
		larg: sy(['Left Argument'], undefined, { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function' }),
		rarg: sy(['Right Argument'], undefined, { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function' }),
		lop: sy(['Left Operand'], undefined, { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function', gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L98' }),
		rop: sy(['Right Operand'], undefined, { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function', gh: 'https://github.com/dzaima/APL/blob/master/docs/chars.txt#L99' }),
		lhyp: sy(['Left Hyperand'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=Anonymous_Functions/Operators/Hyperators#Hyperator_Hyperands' }),
		rhyp: sy(['Right Hyperand'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=Anonymous_Functions/Operators/Hyperators#Hyperator_Hyperands' }),
		axisArg: sy(['Axis Argument'], undefined, { nars2000: 'https://wiki.nars2000.org/index.php?title=Anonymous_Functions/Operators/Hyperators#Axis_Operator' }),
		eaArg: sy(['Extra Arguments'], 'Extra arguments provided to a function or modifier', { tiny: 'https://tinyapl.rubenverg.com/docs/info/extra_arguments' }),
		guard: sy(['Guard'], 'Dfn guard: run RHS if LHS is true', { dyalog: 'https://help.dyalog.com/latest/#Language/Defined%20Functions%20and%20Operators/DynamicFunctions/Guards.htm' }),
		control: sy(['Control Structure'], 'Begin a control structure name', { wiki: 'https://aplwiki.com/wiki/Control_structure' }),
		label: sy(['Label'], 'Target for a branch', { dyalog: 'https://help.dyalog.com/18.2/Content/Language/Defined%20Functions%20and%20Operators/TradFns/Statements.htm' }),
		errorGuard: sy(['Error Guard'], 'If an error of the LHS category occurs, return the RHS', { dyalog: 'https://help.dyalog.com/latest/#Language/Defined%20Functions%20and%20Operators/DynamicFunctions/Error%20Guards.htm' }),
		bindex: sy(['Index'], 'Index into an array', { wiki: 'https://aplwiki.com/wiki/Indexing' }),
		axis: sy(['Function Axis'], 'Specify an axis for a function', { wiki: 'https://aplwiki.com/wiki/Function_axis' }),
		semi: sy(['Axis Separator'], 'Inside a bracket index, separates the different axes', { wiki: 'https://aplwiki.com/wiki/Indexing' }),
		assign: sy(['Assignment'], undefined, { wiki: 'https://aplwiki.com/wiki/Assignment' }),
		assMod: sy(['Modify', 'Assign Modify', 'Modify Assign'], 'Modify an already existing binding'),
		assConst: sy(['Constant', 'Assign Constant', 'Constant Assign', 'Bind'], 'Create an immutable binding'),
		assPriv: sy(['Private Assignment'], 'Create a binding not accessible from outside'),
		return: sy(['Return'], 'Return early from a dfn'),
		sink: sy(['Sink'], 'Don\'t print the result of an expression', { nars2000: 'https://wiki.nars2000.org/index.php?title=Sink' }),
		branch: sy(['Branch'], undefined, { wiki: 'https://aplwiki.com/wiki/Branch' }),
		tradfn: sy(['Tradfn Definition'], undefined, { wiki: 'https://aplwiki.com/wiki/Defined_function_(traditional)' }),
		recfn: sy(['Recurse Function'], 'In a dfn, refer to the dfn itself', { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function', dyalog: 'https://help.dyalog.com/latest/#Language/Defined%20Functions%20and%20Operators/DynamicFunctions/Recursion.htm' }),
		recop: sy(['Recurse Operator'], 'In a dop, refer to the dop itself', { wikipedia: 'https://en.wikipedia.org/wiki/Direct_function', dyalog: 'https://help.dyalog.com/latest/#Language/Defined%20Functions%20and%20Operators/DynamicFunctions/Recursion.htm' }),
		rechyp: sy(['Recurse Hyperator'], 'In a dhyp, refer to the dhyp itself', { nars2000: 'https://wiki.nars2000.org/index.php?title=Anonymous_Functions/Operators/Hyperators#Recursion' }),
		negative: sy(['Negative'], 'Mark a number as negative', { wiki: 'https://aplwiki.com/wiki/High_minus' }),
		inverse: sy(['Inverse'], 'The inverse of a function'),
		dfns: sy(['Dfns Workspace'], 'First character of a dfns workspace name', { wiki: 'https://aplwiki.com/wiki/Dfns_workspace' }),
		eS: sy(['Exponential Separator'], 'Separates the multiplier and exponent of a number'),
		jS: sy(['Complex Separator'], 'Separates the real and imaginary part of a complex number'),
		adS: sy(['Complex Angle Degrees']),
		ahS: sy(['Complex Angle Signed Half Unit']),
		arS: sy(['Complex Angle Radians']),
		auS: sy(['Complex Angle Unsigned Unit']),
		bS: sy(['Base Point Notation']),
		gS: sy(['Gamma Point Notation']),
		pS: sy(['Pi Point Notation']),
		rS: sy(['Rational Notation']),
		vS: sy(['Multiprecision Float']),
		xS: sy(['Euler Point Notation']),
		zS: sy(['Zeta Point Notation']),
		ball: sy(['Ball Arithmetic Notation']),
		ijkS: sy(['Quaternion Notation']),
		ijklS: sy(['Octonion Notation']),
		sep: sy(['Statement Separator']),
		comment: sy(['Comment'], 'Start a comment that ends at the end of the line', { wiki: 'https://aplwiki.com/wiki/Comment' }),
		char: sy(['Character Literal'], 'Character vector/scalar delimiter', { wiki: 'https://aplwiki.com/wiki/String' }),
		str: sy(['String Literal'], 'Like a character literal, but with escapes and always a vector'),
		strEscape: sy(['String Escape'], 'Escape a character in a string'),
		spawn: me([mAy, xdAy], ['Spawn'], 'Run the operand in a green thread', { wiki: 'https://aplwiki.com/wiki/Spawn' }),
		rootNs: me([R], ['Root Namespace'], undefined, { dyalog: 'https://help.dyalog.com/latest/#Language/Introduction/Namespaces/Namespaces.htm' }),
		parentNs: me([R], ['Parent Namespace'], undefined, { dyalog: 'https://help.dyalog.com/latest/#Language/Introduction/Namespaces/Namespaces.htm' }),
		rank: me([My], ['Rank'], undefined, { wiki: 'https://aplwiki.com/wiki/Rank' }),
		formatByExample: me([xDy], ['Format By Example'], 'Format the right argument accoding to the left argument "example"', { wiki: 'https://aplwiki.com/wiki/Format#Dyadic_form' }),
		hex: sy(['Hexadecimal Number'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Section-2_002e14' }),
		bitAnd: me([xDy], ['Bitwise And'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Dyadic-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_003d_002c-and-_005b_003f_005d_005b_003f_005d' }),
		bitOr: me([xDy], ['Bitwise Or'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Dyadic-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_003d_002c-and-_005b_003f_005d_005b_003f_005d' }),
		bitNand: me([xDy], ['Bitwise Nand'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Dyadic-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_003d_002c-and-_005b_003f_005d_005b_003f_005d' }),
		bitNor: me([xDy], ['Bitwise Nor'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Dyadic-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_003d_002c-and-_005b_003f_005d_005b_003f_005d' }),
		bitXor: me([xDy], ['Bitwise Xor'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Dyadic-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_003d_002c-and-_005b_003f_005d_005b_003f_005d' }),
		bitXnor: me([xDy], ['Bitwise Xnor'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Dyadic-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_005b_003f_005d_002c-_005b_003f_005d_003d_002c-and-_005b_003f_005d_005b_003f_005d' }),
		bitAnd0: me([My], ['Bitwise And With 0'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Monadic-_005b_003f_005d_005b_003f_005d' }),
		bitOr0: me([My], ['Bitwise Or With 0'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Monadic-_005b_003f_005d_005b_003f_005d-and-_005b_003f_005d_005b_003f_005d' }),
		bitNor0: me([My], ['Bitwise Nor With 0'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Monadic-_005b_003f_005d_005b_003f_005d-and-_005b_003f_005d_005b_003f_005d' }),
		qrFact: me(['M[v]y'], ['QR Factorization'], undefined, { gnu: 'https://www.gnu.org/software/apl/apl.html#Section-2_002e20' }),
		matrixProduct: me([xDy], ['Matrix Product'], 'Like +.× but faster (and only for matrices)', { gnu: 'https://www.gnu.org/software/apl/apl.html#Section-2_002e41' }),
		conditional: sy(['Conditional'], '???', { gnu: 'https://www.gnu.org/software/apl/apl.html#Section-2_002e40' }),
		sinkF: me([My], ['Sink'], 'Don\'t print the result of an expression', { gnu: 'https://www.gnu.org/software/apl/apl.html#Section-2_002e17' }),
		localVar: sy(['Local Variable'], 'Mark a variable as local inside a tradfn', { wiki: 'https://aplwiki.com/wiki/Defined_function_(traditional)#Semi-colons' }),
		shyRes: sy(['Shy Result'], 'Indicate that a tradfn result is shy', { wiki: 'https://aplwiki.com/wiki/Defined_function_(traditional)#Braces' }),
		optLeft: sy(['Optional Left Argument'], 'Indicate that a tradfn\'s left argument is optional', { wiki: 'https://aplwiki.com/wiki/Defined_function_(traditional)#Braces' }),
		pictureFormat: me([xDy], ['Picture Format'], undefined, { aplx: 'https://microapl.com/apl_help/ch_020_020_670.htm' }),
		fileRead: me([My], ['Read File'], 'Read a component from a file', { aplx: 'https://microapl.com/apl_help/ch_020_020_720.htm' }),
		fileInfo: me([xDy], ['File Info'], 'Read information from a file selected by the left argument', { aplx: 'https://microapl.com/apl_help/ch_020_020_720.htm' }),
		fileRename: me([xDy], ['Rename File'], undefined, { aplx: 'https://microapl.com/apl_help/ch_020_020_720.htm' }),
		fileWrite: me([xDy], ['Write File'], 'Write a component to a file', { aplx: 'https://microapl.com/apl_help/ch_020_020_730.htm' }),
		fileSetAllocation: me([My], ['Set File Allocation Quota'], 'Set how much a file can hold', { aplx: 'https://microapl.com/apl_help/ch_020_020_740.htm' }),
		fileHold: me([xDy], ['File Hold'], 'Lock or unlock a file', { aplx: 'https://microapl.com/apl_help/ch_020_020_740.htm' }),
		fileDeleteC: me([My], ['Delete File Component'], undefined, { aplx: 'https://microapl.com/apl_help/ch_020_020_750.htm' }),
		fileDelete: me([xDy], ['Delete File'], undefined, { aplx: 'https://microapl.com/apl_help/ch_020_020_750.htm' }),
		stop: me([My], ['Stop'], 'Return an empty matrix', { wiki: 'https://aplwiki.com/wiki/Stop', aplx: 'https://microapl.com/apl_help/ch_020_020_753.htm' }),
		lock: sy(['Lock'], 'Lock a function definition, so that it can\'t be read or modified', { aplx: 'https://microapl.com/apl_help/ch_020_020_950.htm' }),
		approxEq: me([xDy], ['Approximately Equal To'], undefined, { gh: 'https://github.com/abrudz/ngn-apl/blob/master/apl.js#L34' }),
		valences: me([mCey, xmCey], ['Valences'], 'Apply the left function if called monadically and the right function if called dyadically'),
		raise: me([My], ['Raise'], 'Raise an exception'),
		idElem: me([dCvy], ['Identity Element'], 'Set the identity element for a function'),
		oneChar: sy(['Character'], 'A literal for a single scalar character', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_character_syntax' }),
		tuple: sy(['Tuple'], 'Separates entries in a tuple literal', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_n_tuples' }),
		globalFn: sy(['Global Function'], undefined, { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_function_definition' }),
		assignFn: sy(['Assign Function'], 'Bind a function to a name', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_local_function_declaration' }),
		createFnRef: sy(['Create Function Reference'], 'Turn a function into a primitive', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_%CE%BB_create_function_reference' }),
		applyFnRef: sy(['Apply Function Reference'], 'Call a function wrapped in a reference', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_apply_function_from_function_reference' }),
		dropFirst: me([My], ['Drop First'], undefined, { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_dropdrop_first' }),
		keyF: me([xDy], ['Key'], 'Unique values of the left array, each paired with the list of corresponding entries from the right array', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_key' }),
		bitwise: me([xdAy, mAy], ['Bitwise'], 'Derive a bitwise function from a boolean function', { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_derive_bitwise' }),
		parallel: me([mAy, xdAy], ['Parallel'], 'Apply a function in parallel (with multiple threads)'),
		inverseF: me([mAy, xdAy], ['Inverse'], undefined, { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_inverse' }),
		withe: me([dCny], ['Withe'], 'Right hook', { wiki: 'https://aplwiki.com/wiki/Withe' }),
		fork: sy(['Fork'], undefined, { kap: 'https://kapdemo.dhsdevelopments.com/reference.html#_and_fork' }),
		member: sy(['Member Access'], 'Access an entry of a namespace/object'),
		decimal: sy(['Decimal Point']),
		bin: sy(['Binary Number']),
		ieeeFloat: sy(['IEEE Float'], 'Floating point number as a hex representation of an IEEE double'),
		adjacent: sy(['Adjacent Output'], 'Print multiple arrays next to each other'),
		digSep: sy(['Digit Separator'], 'Ignored, separates digits for readability'),
		findIdx: me([xDy], ['Find Index'], 'Index of the first true value in the array returned by calling Find on the arguments'),
		link: me([xDy], ['Link'], 'Catenate the enclose of the left argument and the nest of the right argument', { wiki: 'https://aplwiki.com/wiki/Link' }),
		all: me([My], ['All'], 'Cartesian product by catenation of all elements of the argument', { wiki: 'https://aplwiki.com/wiki/Cartesian_Product' }),
		select: me([mAy], ['Select'], 'Apply a function that selects a subset of the elements of an array'),
		saxMerge: me([xmAy], ['Merge'], 'Replace elements of the right argument with elements of the left argument as selected by the operand'),
		tie: me([xuCey], ['Tie'], 'Restrict number of axes used in Cartesian product'),
		cut: me([xuCny, uCny], ['Cut'], 'Apply a function to cuts of an array', { wiki: 'https://aplwiki.com/wiki/Cut' }),
		lineCont: sy(['Line Continuation']),
		joinStr: me([xDy], ['Join Strings'], 'Catenate two strings'),
		toStr: me([My], ['To String'], 'Turn a character vector into a string'),
		fromStr: me([My], ['From String'], 'Turn a string into a charcter vector'),
		inlineComment: sy(['Inline Comment']),
		scalStr: sy(['Scalar String'], 'A string literal that makes a string scalar, instead of a vector of characters'),
		combineSymbols: me([xDy], ['Combine Symbols'], 'Produce qualified names from context names and unqualified names'),
		cast: me([xDy], ['Cast'], 'Cast the right argument to the type specified by the left argument symbol'),
		executeInContext: me([xDy], ['Execute in Context'], '???'),
		protectedExecute: me([xDy], ['Protected Execute'], '???'),
		indexGeneratorE: me([My], ['Index Generator (Enumerate)'], 'Sequence of numbers in the shape specified by the argument (???)', { wiki: 'https://aplwiki.com/wiki/Index_Generator' }),
		laminate: me([xDy], ['Laminate'], 'Join two arrays along a new axis', { wiki: 'https://aplwiki.com/wiki/Laminate' }),
		pack: me([My], ['Pack'], 'Turn character vectors into symbols'),
		unpack: me([My], ['Unpack'], 'Turn symbols into character vectors'),
		apPartition: me([xDy], ['Partition'], '???'),
		partitionCount: me([My], ['Partition Count'], '???'),
		print: me([My], ['Print'], 'Print a value and return it'),
		restructure: me([xDy], ['Restructure'], '???'),
		separateSymbols: me([My], ['Separate Symbols'], 'Split symbols on the last dot'),
		apStop: me([My], ['Stop'], 'Perform an action based on the `stop system variable'),
		apType: me([My], ['Type'], 'A symbol representing the type of the argument'),
		value: me([My], ['Value'], '???'),
		valueInContext: me([xDy], ['Value in Context'], '???'),
		apply: me([uAy, xuAy], ['Apply'], 'Apply the operand function object to the arguments'),
		multilineComment: sy(['Multiline Comment'], 'A comment that can span multiple lines'),
		multilineString: sy(['Multiline String'], 'A string that can span multiple lines'),
		dyadScan: me([xdAy], ['Dyadic Scan'], 'Scan on windows of length of at most the left argument'),
		dyadScanF: me([xdAy], ['Dyadic Scan First']),
		powerLimit: me([xdAy, mAy], ['Power Limit'], 'Repeat a function until a result is returned twice'),
		mask: me([xuAy], ['Mask'], undefined, { wiki: 'https://aplwiki.com/wiki/Mask' }),
		maskF: me([xuAy], ['Mask First'], undefined, { wiki: 'https://aplwiki.com/wiki/Mask' }),
		mesh: me([xuAy], ['Mesh'], undefined, { wiki: 'https://aplwiki.com/wiki/Mesh' }),
		meshF: me([xuAy], ['Mesh First'], undefined, { wiki: 'https://aplwiki.com/wiki/Mesh' }),
		functionTable: me([dAy], ['Function Table'], 'Outer product between ranges defined by the argument'),
		directDef: me(['(∘Av)y', '(uAv)y', 'x(uA∘)y', 'x(uAv)y'], ['Direct Definition'], 'Define an anonymous function', { wiki: 'https://aplwiki.com/wiki/Direct_definition_(operator)' }),
		simple: me([My], ['Simple'], 'Whether the argument is simple (non-nested)'),
		notSimple: me([My], ['Not Simple']),
		span: me([xDy], ['Span'], 'Length of the inclusive range between two numbers', { bqn: 'https://mlochbaum.github.io/BQN/doc/logic.html' }),
		prefixes: me([My], ['Prefixes'], 'The prefixes of an array', { bqn: 'https://mlochbaum.github.io/BQN/doc/prefixes.html' }),
		suffixes: me([My], ['Suffixes'], 'The suffixes of an array', { bqn: 'https://mlochbaum.github.io/BQN/doc/prefixes.html' }),
		windows: me([xDy], ['Windows', 'Infixes'], 'Windows of an array of a certain size', { bqn: 'https://mlochbaum.github.io/BQN/doc/windows.html' }),
		nudge: me([My], ['Nudge'], 'Insert a cell of fill elements at the beginning of the array and drop the last cell', { bqn: 'https://mlochbaum.github.io/BQN/doc/shift.html' }),
		nudgeBack: me([My], ['Nudge Back'], 'Insert a cell of fill elements at the end of the array and drop the first cell', { bqn: 'https://mlochbaum.github.io/BQN/doc/shift.html' }),
		shiftBefore: me([xDy], ['Shift Before'], 'Shift cells of an array into another array from the beginning, dropping the excess', { bqn: 'https://mlochbaum.github.io/BQN/doc/shift.html' }),
		shiftAfter: me([xDy], ['Shift After'], 'Shift cells of an array into another array from the end, dropping the excess', { bqn: 'https://mlochbaum.github.io/BQN/doc/shift.html' }),
		classify: me([My], ['Classify'], 'Mark each unique cell of an array with an incremental natural', { wiki: 'https://aplwiki.com/wiki/Classify', bqn: 'https://mlochbaum.github.io/BQN/doc/selfcmp.html#classify' }),
		occurrenceCount: me([My], ['Occurrence Count'], 'Mark each cell with how many times it has occurred before', { bqn: 'https://mlochbaum.github.io/BQN/doc/selfcmp.html#occurrence-count' }),
		group: me([xDy], ['Group'], 'Collect cells of one array in buckets defined by another', { wiki: 'https://aplwiki.com/wiki/Group_(BQN)', bqn: 'https://mlochbaum.github.io/BQN/doc/group.html' }),
		groupM: me([My], ['Group Indices'], 'Collect indices in buckets defined by an array', { bqn: 'https://mlochbaum.github.io/BQN/doc/group.html' }),
		assert: me([My], ['Assert'], 'Check that the argument is true and throw if not', { bqn: 'https://mlochbaum.github.io/BQN/doc/assert.html' }),
		assertD: me([xDy], ['Assert With Message'], 'Check that the argument is true and throw with message if not', { bqn: 'https://mlochbaum.github.io/BQN/doc/assert.html' }),
		choose: me([mCvy, xdCvy], ['Choose'], 'Choose a function to be called from a list', { bqn: 'https://mlochbaum.github.io/BQN/doc/choose.html' }),
		catch: me([mCny, xdCey], ['Catch', 'Adverse'], 'Call a function and, if it fails, call another', { bqn: 'https://mlochbaum.github.io/BQN/doc/assert.html#catch' }),
		onCells: me([mAy, xdAy], ['On Cells', 'On Major Cells'], 'Call a function on each cell of arrays', { bqn: 'https://mlochbaum.github.io/BQN/doc/rank.html' }),
		onScalars: me([mAy, xdAy], ['On Scalars'], 'Call a function on each scalar of arrays', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/on_scalars' }),
		onSimple: me([mAy, xdAy], ['On Simple Scalars'], 'Call a function on each simple scalar of arrays', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/on_simple_scalars' }),
		vec: sy(['Vector', 'Array', 'Vector Literal', 'Array Literal', 'Array Notation', 'APLAN'], 'Create a vector given elements'),
		hr: sy(['High Rank', 'Array', 'High Rank Literal', 'Array Literal', 'APLAN'], 'Create an array given its major cells'),
		dict: sy(['Dictionary', 'Dictionary Literal', 'APLAN'], 'Create a dictionary given keys and values'),
		kvSep: sy(['Key-Value Separator'], 'Separate keys and values in a dictionary literal'),
		strand: sy(['Strand'], 'Separate entries of a stranded vector literal'),
		train: sy(['Train'], 'Function or modifier train literal'),
		namespace: sy(['Namespace', 'Struct'], 'Create a namespace'),
		ternary: sy(['Ternary', 'If', 'Conditional'], 'Select one of two expressions based on a third'),
		extraArgs: sy(['Extra Arguments'], 'Provide extra arguments to a function or modifier', { tiny: 'https://tinyapl.rubenverg.com/docs/info/extra_arguments' }),
		nothing: sy(['Nothing'], 'Empty tine in a train'),
		defaultBind: me([dCvy, xdCvy, uCey, xuCey], ['Default Bind', 'Bind Default'], 'Bind an argument if it is not provided when the derived function is called', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/default_bind' }),
		round: me([My], ['Round'], 'Round to the nearest integer', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/round' }),
		roundTo: me([xDy], ['Round To Precision'], 'Round to the specified precision', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/round_to_nearest' }),
		realPart: me([My], ['Real Part'], 'The real part of a complex number', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/real_part' }),
		imagPart: me([My], ['Imaginary Part'], 'The imaginary part of a complex number', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/imaginary_part' }),
		phase: me([My], ['Phase'], 'The phase of a complex number', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/phase' }),
		histogram: me([My], ['Histogram', 'Indices Inverse', 'Where Inverse'], 'The inverse of Where', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/histogram' }),
		increment: me([My], ['Increment'], 'Add 1 to the argument', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/increment' }),
		decrement: me([My], ['Decrement'], 'Subtract 1 from the argument', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/decrement' }),
		kvPair: me([xDy], ['Key-Value Pair'], 'Singleton dictionary given key and value', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/key_value_pair' }),
		fromPairs: me([My], ['From Pairs'], 'Dictionary given key-value pairs', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/from_pairs' }),
		fromKV: me([xDy], ['From Keys and Values'], 'Dictionary given keys and values', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/from_keys_and_values' }),
		fromTable: me([My], ['From Inverted Table'], 'Dictionary given inverted table', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/from_inverted_table' }),
		findMask: me([xDy], ['Mask'], 'Find the left argument in the right and mark each occurrence with a number', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/mask' }),
		onPref: me([mAy], ['On Prefixes'], 'Call a function on each prefix of the argument', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/on_prefixes' }),
		onSuf: me([mAy], ['On Suffixes'], 'Call a function on each suffix of the argument', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/on_suffixes' }),
		onInf: me([xmAy], ['On Infixes'], 'Call a function on each infix of the argument', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/on_infixes' }),
		boxed: me([mAy, xdAy], ['Boxed'], 'Enclose the result of the function', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/boxed' }),
		onContents: me([mAy, xdAy], ['On Contents'], 'Disclose the arguments before passing them to the function', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/on_contents' }),
		oneIndex: me([mAy, xdAy], ['One Index', 'Index Origin', '1 Index'], 'Set the index origin of a function to 1', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/one_index' }),
		backward: me([mAy, xdAy], ['Backward'], 'Make a function operate conceptually backward', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/backward' }),
		setTol: me([mCvy, mCny, xdCvy, xdCey], ['Set Tolerance', 'Approximate'], 'Set the tolerance of a function', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/approximate' }),
		fill: me([mCvy, mCny, xdCvy, xdCey], ['Fill', 'Set Fill'], 'Set the fill value of a function', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/fill' }),
		mirror: me([xdCey], ['Mirror'], 'Apply a function to the result of applying another function in both argument orders', { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/mirror' }),
		leftFork: me([xdCey], ['Left Fork'], undefined, { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/left_fork' }),
		rightFork: me([xdCey], ['Right Fork'], undefined, { tiny: 'https://tinyapl.rubenverg.com/docs/primitive/right_fork' }),
	},
	glyphs: [
		gl('+', ['plusId', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['conj', dy, ex, vi, n2, a2, gn, i2, ng, ka, al, co, ty], ['add', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['joinStr', a6]),
		gl('-', ['neg', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['sub', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['flipLetterCase', ex, dz]),
		gl('×', ['sign', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['dir', dy, ex, vi, n2, a2, gn, i2, ng, ka, al, co, ty], ['mul', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['queryLetterCase', ex, dz, ty], ['setLetterCase', ex]),
		gl('÷', ['rec', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['div', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['toTitleCase', ex]),
		gl('*', ['exp', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['pow', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty]),
		gl('⋆', ['exp', bq], ['pow', bq]),
		gl('√', ['sqrt', ex, vi, dz, n2, ka, bq, ty], ['root', ex, vi, dz, n2, ka, bq, ty]),
		gl('⍟', ['ln', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['log', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['repeat', bq]),
		gl('⌹', ['mInv', dy, ex, vi, n2, a2, gn, i1, i2, ax, ng, ka, aw, sv, al, co, sa, a6, ap, na, ty], ['mDiv', dy, ex, vi, n2, a2, gn, i1, i2, ax, ng, ka, aw, sv, al, co, sa, a6, ap, na, ty], ['qrFact', gn]),
		gl('○', ['piT', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, th, sv, al, co, sa, a6, ap, na], ['circ', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, th, sv, al, co, sa, a6, ap, na], ['compose', bq], ['over', bq]),
		gl('!', ['fact', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, na, ty], ['binom', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, na, ty], ['demote', ap], ['restructure', ap], ['assert', bq], ['assertD', bq]),
		gl('?', ['roll', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['deal', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty]),
		gl('|', ['abs', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['mag', dy, ex, vi, n2, a2, gn, i2, ng, ka, al, co, ty], ['mod', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['caseFold', ex, ty]),
		gl('⌈', ['ceil', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['max', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['toUpper', ex, dz, ty]),
		gl('⌊', ['floor', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['min', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['toLower', ex, dz, ty]),
		gl('⸠', ['round', ty], ['roundTo', ty]),
		gl('↾', ['maxTAO', ty]),
		gl('⇂', ['minTAO', ty]),
		gl('⊥', ['decode', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['decode2', ex, dz, ty], ['pack', ap]),
		gl('⊤', ['encode', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['encode2', ex, dz, ty], ['type', n2, na], ['unpack', ap]),
		gl('⊢', ['same', dy, ex, vi, dz, n2, gn, ax, ng, ka, al, co, sa, ap, bq, ty], ['right', dy, ex, vi, dz, n2, gn, i2, ax, ng, ka, al, co, sa, bq, ty]),
		gl('⊣', ['same', dy, ex, vi, dz, n2, ng, co, bq, ty], ['left', dy, ex, vi, dz, n2, gn, i2, ax, ng, ka, al, co, sa, bq, ty], ['stop', gn, ax, ka, al, sa, ap]),
		gl('=', ['eq', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['isType', ex], ['rank', vi, bq], ['dimension', n2], ['nubIn', sa]),
		gl('≠', ['neq', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['nubSieve', dy, vi, ka, al, co, sa, ty], ['isNotType', ex], ['norm', n2], ['tally', bq]),
		gl('≤', ['leq', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['isNonneg', ex], ['isInvisible', ex], ['sortAsc', vi]),
		gl('<', ['le', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['isPos', ex], ['isControl', ex], ['majorCells', vi], ['sortAsc', dz], ['condense', n2], ['promote', ka], ['enclose', sa, ap, bq], ['toStr', a6]),
		gl('>', ['ge', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['isNeg', ex], ['isVisible', ex], ['join', vi], ['sortDesc', dz], ['dilate', n2], ['demote', ka], ['mix', sa, ap, bq], ['fromStr', a6], ['firstCell', ty]),
		gl('≥', ['geq', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['isNonpos', ex], ['isNotControl', ex], ['sortDesc', vi], ['lastCell', ty]),
		gl('≡', ['match', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, aw, al, co, sa, a6, ap, na, bq, ty], ['depth', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, aw, al, co, a6, ap, bq, ty], ['simple', na]),
		gl('≢', ['mismatch', dy, ex, vi, dz, n2, ax, ng, ka, aw, al, co, a6, na, bq, ty], ['tally', dy, ex, vi, dz, n2, ng, ka, al, co, ty], ['notSimple', na], ['shape', bq]),
		gl('⊴', ['pid', ty], ['sortAsc', ty]),
		gl('⊲', ['prec', ty]),
		gl('⊳', ['succ', ty]),
		gl('⊵', ['sid', ty], ['sortDesc', ty]),
		gl('∨', ['or', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['gcd', dy, ex, vi, dz, n2, gn, i2, ng, co, sa, ty], ['sortDesc', ex, ka, bq], ['demote', vi, ty], ['gcdM', dz], ['cast', ap], ['type', ap]),
		gl('∧', ['and', dy, ex, vi, dz, n2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['lcm', dy, ex, vi, dz, n2, gn, i2, ng, co, sa, ty], ['sortAsc', ex, ka, bq], ['promote', vi, ty], ['lcmM', dz], ['apStop', ap]),
		gl('^', ['and', a2]),
		gl('⍱', ['nor', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, na, ty], ['notAllEqualToType', ex], ['none', dz]),
		gl('⍲', ['nand', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, na, ty], ['notAnyEqualToType', ex], ['notAll', dz]),
		gl('↑', ['mix', dy, ex, vi, dz, ng, al, co, na, ty], ['take', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['first', n2, a2, gn, i2, ax, ka, aw, a6], ['nub', sa], ['raise', ap], ['prefixes', bq]),
		gl('↓', ['split', dy, ex, vi, dz, ng, al, co, na], ['drop', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['dropFirst', ka], ['join', sa], ['print', ap], ['suffixes', bq], ['majorCells', ty]),
		gl('⊂', ['enclose', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, aw, al, co, a6, na, ty], ['penclose', dy, ex, vi, dz, ng, al, co, na, ty], ['partition', n2, a2, ax, ka, aw, a6], ['duplicate', sa], ['commute', sa], ['apPartition', ap], ['partitionCount', ap]),
		gl('⊃', ['first', dy, ex, vi, dz, ng, al, co, na, ty], ['pick', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, aw, al, co, a6, ap, na], ['mix', n2, a2, gn, i2, ax, ka, aw, a6], ['nest', sa], ['link', sa], ['join', ap]),
		gl('⊏', ['createFnRef', ty], ['firstCell', bq], ['from', bq]),
		gl('⊑', ['first', bq], ['pick', bq]),
		gl('⊆', ['nest', dy, ex, vi, al, co], ['partition', dy, ex, vi, al, co, ty], ['subset', n2], ['penclose', ka]),
		gl('⫇', ['group', ty]),
		gl('⊔', ['group', bq], ['groupM', bq]),
		gl('⊇', ['discloseIfScalar', ex], ['from', ex, vi, dz, ka, ty], ['last', vi, ty], ['superset', n2]),
		gl('⌷', ['index', dy, ex, vi, dz, n2, a2, gn, ax, ng, ka, aw, al, co, a6, ty], ['materialize', dy, ex, vi, co], ['mapKV', dz]),
		gl('⍋', ['gradeUp', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['gradeUpD', dy, ex, vi, n2, a2, gn, i2, ax, ng, aw, al, co, sa, a6], ['intervalIndex', ap, bq]),
		gl('⍒', ['gradeDown', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['gradeDownD', dy, ex, vi, n2, a2, gn, i2, ax, ng, aw, al, co, sa, a6], ['intervalIndexDown', bq]),
		gl('⍳', ['indexGeneratorR', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, na, ty], ['indexGeneratorI', dy, ex, vi, dz, n2, gn, i2, ng, ka, al, co, a6, na, ty], ['indexOf', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty]),
		gl('↕', ['indexGeneratorR', bq], ['indexGeneratorI', bq], ['windows', bq]),
		gl('⊐', ['applyFnRef', ty], ['indexOf', bq], ['classify', bq]),
		gl('⊒', ['progressiveIndexOf', bq], ['occurrenceCount', bq]),
		gl('⍸', ['where', dy, ex, vi, dz, n2, ka, al, co, ty], ['intervalIndex', dy, ex, vi, al, co, ty], ['arrayLookup', n2], ['findIdx', sa]),
		gl('∊', ['elementOf', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['enlist', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, aw, al, co, a6, ap, ty], ['nubSieve', bq]),
		gl('⍷', ['find', dy, ex, vi, dz, n2, a2, ax, ng, ka, aw, al, co, sa, a6, bq, ty], ['type', ex, vi], ['nub', bq]),
		gl('⋵', ['histogram', ty], ['countIn', ty]),
		gl('⋷', ['findMask', ty]),
		gl('∪', ['union', dy, ex, vi, dz, n2, ax, ng, ka, al, co, na, ty], ['nub', dy, ex, vi, dz, n2, a2, ax, ng, ka, aw, al, co, a6, na, ty], ['combineSymbols', ap], ['separateSymbols', ap]),
		gl('∩', ['intersection', dy, ex, vi, dz, n2, ax, ng, ka, al, co, na, ty], ['nubIn', ex]),
		gl('~', ['not', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['without', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, al, co, sa, na, ty], ['m1', ex], ['laminate', ap]),
		gl('¬', ['not', bq], ['span', bq]),
		gl('§', ['symDiff', n2, ty]),
		gl('/', ['reduce', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na], ['wreduce', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, al, co, na], ['compress', dy, ex, vi, n2, gn, i1, i2, ng, ka, th, sv, al, co, na], ['replicate', dy, ex, vi, n2, gn, i2, ng, ka, al, co, ap, na], ['compressO', a2, ax, aw, sa, a6], ['replicateO', a2, ax, aw, a6], ['where', bq], ['reduceLF', ty], ['replicateF', bq]),
		gl('⌿', ['reduceF', dy, ex, vi, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, na], ['wreduceF', dy, ex, vi, n2, a2, gn, i2, ax, ng, ka, al, co, na], ['compressF', dy, ex, vi, dz, n2, gn, i1, i2, ng, ka, th, sv, al, co, na], ['replicateF', dy, ex, vi, dz, n2, gn, i2, ng, ka, al, co, na, ty], ['compressOF', a2, ax, aw, sa, a6], ['replicateOF', a2, ax, aw, a6]),
		gl('´', ['reduceF', bq]),
		gl('\\', ['scan', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, sv, al, co, sa, a6, ap, na], ['expand', dy, ex, vi, dz, n2, gn, i1, i2, ng, ka, th, sv, al, co, ap, na], ['outerProduct', ex], ['expandO', a2, ax, aw, sa, a6], ['dyadScan', na], ['reduceF', ty]),
		gl('⍀', ['scanF', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, sv, al, co, sa, a6, na], ['expandF', dy, ex, vi, dz, n2, gn, i1, i2, ng, ka, th, sv, al, co, na], ['applyRight', ex], ['expandOF', a2, ax, aw, sa, a6], ['dyadScanF', na]),
		gl('`', ['scanF', bq]),
		gl(',', ['ravel', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['cat', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na], ['laminate', ty]),
		gl('∾', ['join', bq], ['cat', bq]),
		gl('⍪', ['table', dy, ex, vi, dz, n2, gn, i2, ng, ka, al, co, sa], ['catF', dy, ex, vi, dz, n2, gn, i2, ax, ng, ka, aw, al, co, sa, a6, na, ty], ['ravel', ax], ['join', ty]),
		gl('⍴', ['shape', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty], ['reshape', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, ty]),
		gl('ϼ', ['rank', ty], ['rerank', ty]),
		gl('⥊', ['ravel', bq], ['reshape', bq]),
		gl('⌽', ['reverse', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na], ['rotate', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na], ['reverseF', bq], ['rotateF', bq]),
		gl('⊖', ['reverseF', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ty], ['rotateF', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ty]),
		gl('⍉', ['transpose', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty], ['transposeD', dy, ex, vi, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na, bq, ty]),
		gl('¨', ['each1', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, al, co, ap, na, bq, ty], ['each2', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, al, co, ap, na, bq, ty], ['under', sa], ['bind', sa], ['apply', ap]),
		gl('◡', ['onCells', ty]),
		gl('˘', ['onCells', bq]),
		gl('◠', ['onScalars', ty]),
		gl('⌓', ['onSimple', ty]),
		gl('⍨', ['constant', dy, ex, vi, dz, al, co,  ty], ['commute', dy, ex, vi, dz, n2, gn, i2, ng, ka, aw, al, co, a6, na, ty], ['duplicate', dy, ex, vi, dz, n2, gn, i2, ng, ka, al, co, ty], ['bitwise', ap]),
		gl('˙', ['constant', bq]),
		gl('˜', ['commute', bq], ['duplicate', bq]),
		gl('⍣', ['repeat', dy, ex, vi, dz, n2, ng, ka, al, co, na, ty], ['until', dy, ex, vi, dz, n2, ng, ka, al, co, ty]),
		gl('⍡', ['cumulativeRepeat', dz], ['convolution', n2, na]),
		gl('.', ['innerProduct', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na], ['alternant', n2, sa], ['member', dy, ex, vi, dz, gn, ka, aw, co, a6], ['decimal', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ty], ['tie', sa], ['repeat', sa]),
		gl('∙', ['innerProduct', ex, ka, ty], ['alternant', ex]),
		gl('∘.', ['outerProduct', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, na], ['functionTable', na]),
		gl('∘∙', ['outerProduct', ka]),
		gl('⊞', ['outerProduct', ty]),
		gl('∘', ['compose', dy, ex, vi, dz, n2, ng, al, co, na, bq, ty], ['after', dy, ex, vi, dz, n2, ng, ka, al, co, na, ty], ['bind', dy, ex, vi, dz, n2, ng, al, co, na, ty], ['matrixProduct', gn], ['withe', ka], ['atop', bq]),
		gl('⍛', ['before', ex, vi, dz, ka, al, ty], ['defaultBind', ty]),
		gl('⊸', ['before', bq, ty]),
		gl('⟜', ['withe', bq, ty]),
		gl('⍤', ['compose', dy, ex, vi, dz, n2, al, co, sa, ty], ['atop', dy, ex, vi, dz, n2, al, co, ty], ['atRank', dy, ex, vi, n2, gn, i2, ka, al, co, sa, ty], ['over', sa], ['cut', sa]),
		gl('⎉', ['atRank', bq]),
		gl('⍥', ['compose', dy, ex, vi, dz, n2, ka, al, co, sa, ty], ['over', dy, ex, vi, dz, n2, ka, al, co, ty], ['atDepth', ex, vi, ty], ['atop', sa]),
		gl('⚇', ['atDepth', bq]),
		gl('⸚', ['mirror', ty]),
		gl('⇾', ['leftFork', ty]),
		gl('⇽', ['rightFork', ty]),
		gl('⍢', ['under', ex, vi, dz, ka, na, ty]),
		gl('ᐵ', ['eachLeft', dz, ty]),
		gl('ᑈ', ['eachRight', dz, ty]),
		gl('ᓗ', ['cellsLeft', ty]),
		gl('ᓚ', ['cellsRight', ty]),
		gl('@', ['at', dy, ex, vi, dz, al, co], ['oneChar', ka], ['from', sa], ['all', sa], ['rank', ap]),
		gl('⍫', ['obverse', ex, vi, dz], ['lock', a2, ax], ['return', ng]),
		gl('⎕', ['evalInput', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, th, sv, al, co, a6, ty], ['stdout', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, th, sv, al, co, a6, ty], ['sys', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, sv, al, co, a6, ty]),
		gl('⍞', ['stringInput', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, th, sv, al, co, a6, ty], ['stderr', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, th, sv, al, co, a6, ty], ['applyFnRef', ka]),
		gl('⍠', ['variant', dy, ex, vi, n2], ['valences', ng]),
		gl('⁖', ['valences', ty]),
		gl('⊘', ['valences', bq]),
		gl('⌸', ['keyI', dy, ex, vi, dz, ng, al, co, ty], ['keyV', dy, ex, vi, dz, ng, al, co, ty], ['keyVocI', vi], ['keyVocV', vi], ['getMap', dz], ['setMap', dz], ['keyF', ka]),
		gl('⍁', ['diagonals', dz], ['idElem', ng]),
		gl('⌺', ['stencil', dy, ex, vi, al, co]),
		gl('↟', ['onPref', ty]),
		gl('↡', ['onSuf', ty], ['onInf', ty]),
		gl('⌶', ['beam', dy, ex, vi, co]),
		gl('ᑣ', ['boxed', ty]),
		gl('ᑒ', ['onContents', ty]),
		gl('⍎', ['execute', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, sv, al, sa, a6, ap, na, ty], ['executeInContext', ap], ['protectedExecute', ap]),
		gl('⍕', ['format', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, sv, al, sa, a6, ap, na, ty], ['dformat', dy, ex, vi, n2, a2, gn, i1, i2, ax, aw, sv, al, sa, a6, ap, na], ['formatByExample', a2, ax, sa]),
		gl('⍬', ['zilde', dy, ex, vi, dz, n2, ax, ng, ka, aw, al, co, a6, na, ty]),
		gl('∻', ['emptyDict', ty]),
		gl('∞', ['inf', ex, dz, n2, ng, ty]),
		gl('¯∞', ['ninf', ex, dz, n2, ng, ty]),
		gl('∅', ['nan', n2]),
		gl('#', ['rootNs', dy, ex, vi, co], ['from', ap], ['tally', ap]),
		gl('##', ['parentNs', dy, ex, vi, co]),
		gl('⌾', ['cartD', ex], ['cartM', ex], ['outerProduct', dz], ['under', bq]),
		gl('⊕', ['cartM', ty], ['cartD', ty]),
		gl('⊗', ['polarM', ty], ['polarD', ty]),
		gl('⌜', ['outerProduct', bq]),
		gl('$', ['mstringE', ex, vi], ['dstringE', ex, vi], ['hex', gn], ['conditional', al]),
		gl('…', ['range', ex, dz, ka, ty]),
		gl('..', ['range', n2]),
		gl('⍦', ['multisets', n2]),
		gl('⍧', ['nubSieve', ex, dz], ['countIn', ex, dz]),
		gl('%', ['probab', ex], ['merge', dz, ka], ['value', ap], ['valueInContext', ap]),
		gl('⍮', ['pair', ex, dz, ka, ty], ['singleton', ex, dz, ka, ty]),
		gl('⋈', ['pair', bq], ['singleton', bq]),
		gl('ℜ', ['realPart', ty]),
		gl('ℑ', ['imagPart', ty]),
		gl('∡', ['phase', ty]),
		gl('⧺', ['increment', ty]),
		gl('ⵧ', ['decrement', ty], ['span', ty]),
		gl('߹', ['kvPair', ty], ['fromPairs', ty]),
		gl('‥', ['fromTable', ty], ['fromKV', ty]),
		gl('≍', ['promote', bq], ['laminate', bq]),
		gl('⍭', ['factors', ex], ['primeRelated', ex]),
		gl('π', ['primeFactors', n2], ['primeRelated', n2]),
		gl('⊙', ['null', n2]),
		gl('⫤', ['null', ty]),
		gl('⊩', ['dex', ty]),
		gl('⫣', ['lev', ty]),
		gl('⑴', ['oneIndex', ty]),
		gl('⤺', ['backward', ty]),
		gl('⬚', ['fill', ty]),
		gl('‼', ['combinatorial', n2]),
		gl('⌻', ['matrix', n2], ['outerProduct', ka]),
		gl('∂', ['deriv', n2]),
		gl('∫', ['integ', n2]),
		gl('⍑', ['transform', n2]),
		gl('&', ['spawn', dy, ex, vi], ['select', sa], ['saxMerge', sa]),
		gl('⊤∧', ['bitAnd', gn], ['bitAnd0', gn]),
		gl('⊤∨', ['bitOr', gn], ['bitOr0', gn]),
		gl('⊤⍲', ['bitNand', gn]),
		gl('⊤⍱', ['bitNor', gn], ['bitNor0', gn]),
		gl('⊤≠', ['bitXor', gn]),
		gl('⊤=', ['bitXnor', gn]),
		gl('⍇', ['fileRead', ax], ['fileInfo', ax], ['fileRename', ax]),
		gl('⍈', ['fileWrite', ax]),
		gl('⍐', ['fileSetAllocation', ax], ['fileHold', ax]),
		gl('⍗', ['fileDelete', ax], ['fileDeleteC', ax]),
		gl('≈', ['approxEq', ng], ['setTol', ty]),
		gl('↗', ['raise', ng, ty]),
		gl('⫽', ['compress', ka], ['replicate', ka]),
		gl('∵', ['bitwise', ka, ty]),
		gl('∥', ['parallel', ka]),
		gl('˝', ['inverseF', ka], ['reduceF', bq]),
		gl('⁼', ['inverseF', bq]),
		gl('⍣∘', ['powerLimit', na]),
		gl('∘/', ['mask', n2, na]),
		gl('∘⌿', ['maskF', n2, na]),
		gl('∘\\', ['mesh', n2, na]),
		gl('∘⍀', ['meshF', n2, na]),
		gl('»', ['nudge', bq], ['shiftBefore', bq]),
		gl('«', ['nudgeBack', bq], ['shiftAfter', bq]),
		gl('◶', ['choose', bq]),
		gl('⎊', ['catch', bq]),
		gl('{}', ['dfn', dy, ex, vi, dz, n2, gn, ng, ka, al, co, ty], ['dop', dy, ex, vi, dz, n2, gn, ng, al, co, ty], ['dhyp', n2], ['shyRes', dy, ex, vi, n2, a2, gn, co], ['optLeft', dy, ex, vi, co]),
		gl('⍺', ['larg', dy, ex, vi, dz, n2, gn, ng, ka, al, co, ty], ['pictureFormat', ax]),
		gl('⍵', ['rarg', dy, ex, vi, dz, n2, gn, ng, ka, al, co, ty]),
		gl('⍺⍺', ['lop', dy, ex, vi, n2, al, co, ty]),
		gl('⍶', ['lop', dz, gn, ng]),
		gl('⍶⍶', ['lop', ty]),
		gl('⍵⍵', ['rop', dy, ex, vi, n2, al, co, ty]),
		gl('⍹', ['rop', dz, gn, ng]),
		gl('⍹⍹', ['rop', ty]),
		gl('⍺⍺⍺', ['lhyp', n2]),
		gl('⍵⍵⍵', ['rhyp', n2]),
		gl('χ', ['axisArg', n2, gn]),
		gl('ɛ', ['eaArg', ty]),
		gl(':', ['guard', dy, ex, vi, dz, n2, co, ty], ['control', dy, ex, vi, n2, aw, a6], ['label', dy, ex, vi, gn, i2, aw, co, sa, a6], ['kvSep', ty]),
		gl('::', ['errorGuard', dy, ex, vi]),
		gl('[]', ['bindex', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, ng, th, sv, al, co, sa, a6, ap, na], ['axis', dy, ex, vi, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, na], ['hr', ty]),
		gl(';', ['semi', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, aw, ng, ka, th, sv, al, co, sa, a6, ap], ['localVar', dy, ex, vi, n2, a2, gn, i1, i2, ax, aw, th, sv, a6], ['tuple', ka], ['adjacent', th, sv]),
		gl('←', ['assign', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ap, ty], ['return', dz, ap], ['sink', n2, aw, a6, na]),
		gl('⇐', ['assignFn', ka]),
		gl('↩', ['assMod', ty]),
		gl('⇇', ['assConst', ty]),
		gl('↚', ['assPriv', ty]),
		gl('→', ['branch', dy, ex, vi, n2, a2, gn, i2, ax, aw, al, sa, a6], ['return', ka], ['member', ty]),
		gl('■', ['return', ty]),
		gl('∇', ['tradfn', dy, ex, vi, n2, a2, gn, i1, i2, ax, aw, th, sv, sa, a6, ty], ['recfn', dy, ex, vi, dz, n2, ng, al, co], ['globalFn', ka], ['directDef', na]),
		gl('∇∇', ['recop', dy, ex, vi, n2, co]),
		gl('_∇', ['recop', ty]),
		gl('_∇_', ['recop', ty]),
		gl('∇∇∇', ['rechyp', n2]),
		gl('¯', ['negative', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ty], ['inverse', ex]),
		gl('⌂', ['dfns', ex]),
		gl('E', ['eS', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6]),
		gl('e', ['eS', dy, ex, vi, dz, n2, ng, ka, co, sa]),
		gl('⏨', ['eS', ty]),
		gl('J', ['jS', dy, ex, vi, n2, a2, gn, i2, ng, ka, co]),
		gl('j', ['jS', dy, ex, vi, ng, ka, co]),
		gl('i', ['jS', n2]),
		gl('ᴊ', ['jS', ty]),
		gl('D', ['adS', a2]),
		gl('R', ['arS', a2]),
		gl('ad', ['adS', n2]),
		gl('ah', ['ahS', n2]),
		gl('ar', ['arS', n2]),
		gl('au', ['auS', n2]),
		gl('b', ['bS', n2]),
		gl('g', ['gS', n2]),
		gl('p', ['pS', n2]),
		gl('r', ['rS', n2, al]),
		gl('v', ['vS', n2]),
		gl('x', ['xS', n2]),
		gl('z', ['zS', n2]),
		gl('±', ['ball', n2]),
		gl('ijk', ['ijkS', n2]),
		gl('ijkl', ['ijklS', n2]),
		gl('0x', ['hex', ka, aw, a6]),
		gl('0X', ['hex', aw, a6]),
		gl('0b', ['bin', aw, a6]),
		gl('0B', ['bin', aw, a6]),
		gl('0r', ['ieeeFloat', aw, a6]),
		gl('0R', ['ieeeFloat', aw, a6]),
		gl('⋄', ['sep', dy, ex, vi, dz, n2, a2, gn, i2, ax, ng, ka, aw, al, co, sa, a6, ty]),
		gl('⍝', ['comment', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, ka, aw, th, sv, al, co, sa, a6, ty]),
		gl('⟃⟄', ['inlineComment', a6, ty]),
		gl('⟃⟃⟄⟄', ['multilineComment', a6]),
		gl('\'', ['char', dy, ex, vi, dz, n2, a2, gn, i1, i2, ax, ng, aw, th, sv, al, co, sa, a6, ty]),
		gl('"', ['str', dz, gn, ka, ty], ['char', ax, aw, a6]),
		gl('⍘', ['strEscape', ty]),
		gl('"""', ['multilineString', gn]),
		gl('λ', ['createFnRef', ka]),
		gl('«»', ['fork', ka, ty], ['scalStr', a6]),
		gl('««»»', ['multilineString', a6]),
		gl('_', ['digSep', al]),
		gl('➥', ['lineCont', n2]),
		gl('⟨⟩', ['vec', ty], ['dict', ty]),
		gl('‿', ['strand', ty]),
		gl('⦅⦆', ['train', ty]),
		gl('·', ['nothing', ty]),
		gl('⦃⦄', ['namespace', ty]),
		gl('⍰⍠', ['ternary', ty]),
		gl('⦋⦌', ['extraArgs', ty]),
	],
};

if (new Set(glyphs.glyphs.map(({ glyph }) => glyph)).size !== glyphs.glyphs.length) {
	const gl = [];
	for (const [ind, { glyph }] of glyphs.glyphs.entries())
		if (glyphs.glyphs.findIndex(g => g.glyph === glyph) !== ind) gl.push(glyph);
	throw new Error(`Duplicate glyphs! ${gl.join(' ')}`);
}
